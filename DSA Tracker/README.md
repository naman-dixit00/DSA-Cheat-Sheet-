| #   | DS Name                        | Algorithm Used                        | Patterns Used                                 | ✅ |
| --- | ------------------------------ | ------------------------------------ | -------------------------------------------- | --- |
| 1   | Array                          | Prefix Sum, Sliding Window            | Sliding Window, Prefix Sum                    | [ ] |
| 2   | Matrix                         | BFS/DFS, DP                           | BFS in Grid, DP, Prefix Sum                   | [ ] |
| 3   | Linked List                    | Two Pointers, In-place Reversal       | Fast-Slow Pointers, Reversal, Cycle Detection | [ ] |
| 4   | Stack                          | Monotonic Stack, Parenthesis Matching | Stack-based Problems, Monotonic Stack         | [ ] |
| 5   | Queue                          | BFS, Sliding Window                   | Monotonic Queue, Deque Sliding Window         | [ ] |
| 6   | Heap / Priority Queue          | Top K, Dijkstra, Kth Smallest         | Top K Elements, Heap, Greedy                  | [ ] |
| 7   | HashMap / HashSet              | Frequency Count, LRU Cache            | Hashing, Map+Sliding Window                   | [ ] |
| 8   | Trie                           | Word Search, Aho-Corasick             | Trie + DFS, Trie + DP                         | [ ] |
| 9   | Graph                          | BFS, DFS, Dijkstra, MST, SCC          | DFS, BFS, Union-Find, DSU, Topo Sort          | [ ] |
| 10  | Binary Search Tree (BST)       | Search, Delete, Insert                | Recursion, Binary Search                      | [ ] |
| 11  | Balanced BST (AVL/Splay/RB)    | Rotation Handling                     | Tree Structure, Search Optimization           | [ ] |
| 12  | Segment Tree                   | Range Query/Update                    | Segment Tree, Lazy Propagation                | [ ] |
| 13  | Binary Indexed Tree (Fenwick)  | Prefix Sums                           | BIT, Range Queries                            | [ ] |
| 14  | Suffix Array                   | LCP, Lexical Order                    | String Algorithms, Z-Function, KMP            | [ ] |
| 15  | Suffix Tree                    | Pattern Matching                      | Suffix Tree, Traversal                        | [ ] |
| 16  | Dynamic Programming            | Memo, Tabulation                      | 0/1 Knapsack, Unbounded Knapsack              | [ ] |
| 17  | Disjoint Set Union (DSU)       | Union by Rank + Path Compression      | Union Find, Kruskal’s                         | [ ] |
| 18  | Sliding Window                 | Fixed/Variable Window                 | Sliding Window, Two Pointers                  | [ ] |
| 19  | Two Pointers                   | Left/Right Scan                       | Two Pointers, Subarray                        | [ ] |
| 20  | Fast & Slow Pointers           | Cycle Detection                       | Linked List Cycles                            | [ ] |
| 21  | Merge Intervals                | Sort + Merge                          | Greedy + Sorting                              | [ ] |
| 22  | Backtracking                   | Sudoku, N-Queens                      | Recursion, State-space Search                 | [ ] |
| 23  | Recursion                      | Divide & Conquer                      | Tree, DFS, Permutations                       | [ ] |
| 24  | Permutations                   | DFS, Backtracking                     | Subsets, Recursion                            | [ ] |
| 25  | Subsets                        | Bitmask, Backtracking                 | Subsets, Submasks                             | [ ] |
| 26  | Bitmasking                     | Bitwise Operations                    | Bitmask DP, XOR                               | [ ] |
| 27  | Topological Sort               | Kahn's/DFS                            | Directed Graph, Cycle Detection               | [ ] |
| 28  | Shortest Path in Grid          | BFS + Distance Grid                   | BFS for Shortest Path                         | [ ] |
| 29  | 0/1 Knapsack                   | DP Table                              | Tabulation, Memoization                       | [ ] |
| 30  | Coin Change                    | DP Optimization                       | Unbounded Knapsack, Greedy                    | [ ] |
| 31  | Palindromic Substring          | Expand Around Center                  | DP, Two Pointers                              | [ ] |
| 32  | Palindrome Partitioning        | DFS + DP                              | Backtracking + Memo                           | [ ] |
| 33  | Longest Common Subsequence     | Classic 2D DP                         | Memoization, Tabulation                       | [ ] |
| 34  | Longest Increasing Subsequence | Binary Search + DP                    | Patience Sorting                              | [ ] |
| 35  | Kth Smallest Element           | Heap or QuickSelect                   | Kth Element, Top-K                            | [ ] |
| 36  | Modified Binary Search         | Infinite Search Space                 | Binary Search on Answer                       | [ ] |
| 37  | Ternary Search                 | Minimize Functions                    | Divide & Conquer, BS                          | [ ] |
| 38  | Tree Flattening                | Euler Tour, LCA                       | Binary Lifting, DFS Traversal                 | [ ] |
| 39  | Lowest Common Ancestor (LCA)   | Binary Lifting, Euler Tour            | Tree DP, RMQ                                  | [ ] |
| 40  | Manacher’s Algorithm           | Palindromic Substrings                | String Algorithms                             | [ ] |
| 41  | KMP Algorithm                  | Prefix Table                          | String Matching, Z-Algorithm                  | [ ] |
| 42  | Rabin-Karp                     | Rolling Hash                          | Pattern Matching, Hashing                     | [ ] |
| 43  | Z-Algorithm                    | Z-array Construction                  | String Matching                               | [ ] |
| 44  | Rolling Hash                   | Polynomial Hashing                    | Substring Search, String Hashing              | [ ] |
| 45  | Trie + DP                      | Memo with Prefix Tree                 | Word Break, Trie Optimization                 | [ ] |
| 46  | Trie + DFS                     | Word Path Finding                     | Word Search, Prefix Tree                      | [ ] |
| 47  | Binary Lifting                 | Ancestor Jumps                        | LCA, Tree Queries                             | [ ] |
| 48  | Euler Tour Technique           | Tree Traversal Numbering              | Tree Flattening, LCA                          | [ ] |
| 49  | Bitmask DP                     | DP on Subsets                         | TSP, Assignment Problems                      | [ ] |
| 50  | Digit DP                       | Recursion with Digits                 | Count Range Numbers                           | [ ] |
| 51  | Inclusion-Exclusion            | Subset Overlap Combinatorics          | Bitmask Combinations                          | [ ] |
| 52  | Meet in the Middle             | Divide Array in Half                  | Subset Sum, Count Combinations                | [ ] |
| 53  | Sieve of Eratosthenes          | Prime Marking                         | Number Theory, Preprocessing                  | [ ] |
| 54  | Segmented Sieve                | Range Prime Detection                 | Prime Queries                                 | [ ] |
| 55  | Modular Inverse                | Fermat/Extended Euclid                | Modulo Division                               | [ ] |
| 56  | Chinese Remainder Theorem      | Modular Congruences                   | Number Theory                                 | [ ] |
| 57  | Extended Euclidean Algorithm   | Linear Diophantine Solver             | GCD, Modular Inverse                          | [ ] |
| 58  | Game Theory                    | Grundy Numbers, XOR of Heaps          | Nim Game, Sprague-Grundy                      | [ ] |
| 59  | 2-SAT                          | Implication Graph + SCC               | Boolean Formula Check                         | [ ] |
| 60  | Tarjan’s Algorithm             | Low-Link Values                       | Bridges, Articulation Points                  | [ ] |
| 61  | Kosaraju’s Algorithm           | Reverse DFS Pass                      | Strongly Connected Components                 | [ ] |
| 62  | Graph Coloring                 | DFS Coloring                          | Bipartite Check                               | [ ] |
| 63  | Flow Algorithms                | Ford-Fulkerson, Dinic                 | Max Flow, Min Cut                             | [ ] |
| 64  | Min-Cost Max Flow              | SPFA / Bellman + Flow                 | Bipartite Matching                            | [ ] |
| 65  | Aho-Corasick                   | Multi-pattern Automaton               | Pattern Matching, Trie                        | [ ] |
| 66  | Suffix Automaton               | State Graph of Suffixes               | LCS, Pattern Occurrences                      | [ ] |
| 67  | Persistent Segment Tree        | Functional Updates                    | Time Travel Querying                          | [ ] |
| 68  | Cartesian Tree                 | RMQ with Tree                         | Tree from Array                               | [ ] |
| 69  | Skip List                      | Probabilistic BST                     | Sorted Insertion                              | [ ] |
| 70  | KD Tree                        | Multidimensional Point Query          | Nearest Neighbors                             | [ ] |
| 71  | Range Tree                     | Segment Tree in Higher Dimensions     | Range Count Queries                           | [ ] |
| 72  | Bloom Filter                   | Probabilistic Hashing                 | Membership Testing                            | [ ] |
| 73  | Bitset / Bitmask Array         | Bitwise Storage                       | Space Optimized Subsets                       | [ ] |
| 74  | Rolling Median                 | Two Heaps                             | Online Median Finding                         | [ ] |
| 75  | LRU / LFU Cache                | Hash + DLL                            | Memory Cache Simulation                       | [ ] |
| 76  | Histogram Largest Rectangle    | Stack, Nearest Smaller                | Monotonic Stack                               | [ ] |
| 77  | Randomized Algorithms          | Reservoir Sampling, QuickSelect       | Probability-based Logic                       | [ ] |
| 78  | Tree DP                        | Subtree Properties                    | Children to Root Aggregation                  | [ ] |
| 79  | Heavy-Light Decomposition      | Chain Decomposition                   | Tree Queries                                  | [ ] |
| 80  | Centroid Decomposition         | Recursive Tree Splitting              | Optimization Queries                          | [ ] |
| 81  | Binary Search on Answer        | Range Decision Making                 | BS, Parametric Search                         | [ ] |
| 82  | Greedy Interval Scheduling     | Sort + Select                         | Greedy, Interval Problems                     | [ ] |
| 83  | Sweep Line Algorithm           | Event Sorting + Set Handling          | Line Sweep, Geometry                          | [ ] |
| 84  | Line Sweep + Active Set        | Set + Sort Combination                | Geometry, Segment Intersections               | [ ] |
| 85  | Deque Sliding Window           | Max/Min in Window                     | Monotonic Queue, Deque                        | [ ] |
| 86  | Nearest Greater/Smaller        | Stack-based Span                      | Monotonic Stack, NSE/PSE                      | [ ] |
| 87  | Min/Max Stack                  | Stack with Auxiliary                  | Stack Enhancement                             | [ ] |
| 88  | Balanced Parenthesis Check     | Stack Parsing                         | Stack-Based Problems                          | [ ] |
| 89  | DFS Tree Flattening            | Time In/Out Arrays                    | LCA, Euler Tour                               | [ ] |
| 90  | Implicit Treap                 | Implicit Indexing + BST               | Split/Merge BST                               | [ ] |
| 91  | Sqrt Decomposition             | Block-wise Querying                   | Array Chunking                                | [ ] |
| 92  | Sparse Table                   | Precomputed RMQ                       | Logarithmic RMQ                               | [ ] |
| 93  | Offline Query Handling         | Sort Queries by Constraint            | Mo’s Algorithm                                | [ ] |
| 94  | Simulation / Greedy-Simulation | Rule-Based Movement                   | BFS + Heuristics                              | [ ] |
| 95  | Interactive Problems           | Binary Search in Queries              | Strategy Adaptation                           | [ ] |
| 96  | String Automaton               | Finite State Machine                  | String Matching                               | [ ] |
| 97  | Modular Exponentiation         | Fast Power                            | Binary Exponentiation                         | [ ] |
| 98  | Ford-Fulkerson Algorithm       | Residual Graph + DFS                  | Flow Network                                  | [ ] |
| 99  | Edmonds-Karp Algorithm         | BFS Based Max Flow                    | Network Flow                                  | [ ] |
| 100 | Dinic's Algorithm              | Level Graph + Blocking Flow           | Efficient Max Flow                            | [ ] |
| 101 | Trie + Aho-Corasick            | Combined Automaton                    | Fast Pattern Match                            | [ ] |
| 102 | TreeMap / TreeSet              | Balanced BST Map                      | Ordered Map/Set                               | [ ] |
| 103 | MultiSet / MultiMap            | STL Based Structures                  | Duplicates in Maps                            | [ ] |
| 104 | Randomized BST (RBST)          | Random Priority Trees                 | Treap Variant                                 | [ ] |
| 105 | Virtual Tree Construction      | LCA-based Tree Building               | HLD, LCA, Subtree Merging                     | [ ] |
| 106 | Range Minimum Query (RMQ)      | Segment Tree, Sparse Table            | Query Optimization                            | [ ] |
| 107 | Difference Array               | Range Updates                         | Prefix Diff, Interval Update                  | [ ] |
| 108 | Interval Tree                  | Overlap Intervals                     | Range Handling                                | [ ] |
| 109 | Tree Structure in DP           | DP by DFS Tree Traversal              | Tree DP                                       | [ ] |
| 110 | Fenwick Tree with Range Update | Dual BIT                              | Advanced BIT                                  | [ ] |
| 111 | Convex Hull                    | Graham Scan                           | Geometry, Points Convex                       | [ ] |
| 112 | Geometry Basics                | Orientation, Area, Distance           | Line Sweep, Convex Hull                       | [ ] |
| 113 | Orientation Test               | Cross Product                         | Geometry Building Block                       | [ ] |
| 114 | Matching Algorithms            | Hungarian, Hopcroft-Karp              | Bipartite Matching                            | [ ] |
| 115 | Hopcroft-Karp Algorithm        | BFS + DFS Matching                    | Max Matching in Bipartite                     | [ ] |
| 116 | Persistent BIT                 | Functional BIT                        | Versioned Queries                             | [ ] |
| 117 | RMQ with Cartesian Tree        | LCA in Arrays                         | Min Query from Structure                      | [ ] |
| 118 | Balanced Partitioning          | Subset Splitting                      | Meet in Middle                                | [ ] |
| 119 | Graph Compression              | Contract Nodes                        | DAG Optimization                              | [ ] |
| 120 | Puzzle Solvers                 | BFS/DFS/Heuristic                     | State Compression                             | [ ] |
| 121 | Binary Trie + XOR Queries      | XOR Maximization                      | Bit Trie Optimization                         | [ ] |
| 122 | Suffix Trie                    | Suffix Insertion                      | Pattern Search                                | [ ] |
| 123 | String Matching with Hashing   | Hash Comparison                       | Karp-Rabin                                    | [ ] |
| 124 | Game Theory Grundy             | State XOR Analysis                    | Sprague-Grundy                                | [ ] |
| 125 | Tree-Based Bitmask DP          | Bitmask per Subtree                   | Tree + Bitmask DP                             | [ ] |

                    

# FAANG Core DSA Cheat Sheet (MIT-Level)

> **Scope:** Core Data Structures & Algorithms most frequently asked in FAANG interviews (Facebook/Meta, Amazon, Apple, Netflix, Google).  
> **Goal:** Pattern recognition, problem-solving frameworks, and optimization.

---

## Sliding Window
**Concept:** Maintain a dynamic window over data for subarray/subsequence problems.  
**Use-Cases:**
- Maximum/Minimum sum subarray of size `k`
- Longest substring without repeating characters
- String anagrams
- Subarray sum constraints  
**Key Insight:** Adjust window boundaries while maintaining invariants.

---

## Two Pointers
**Concept:** Use two iterators to traverse efficiently.  
**Use-Cases:**
- Pair sum / triplet in sorted array
- Remove duplicates
- Reverse array / linked list
- Container With Most Water  
**Key Insight:** Move one pointer based on conditional checks.

---

## BFS / DFS
**Concept:** Graph/Tree traversal frameworks.  
**BFS:** Level-order traversal, shortest path in unweighted graph.  
**DFS:** Explore deeply; used for connectivity, cycles, topological sorting.  
**Use-Cases:**
- Word Ladder  
- Clone Graph  
- Binary Tree level order traversal  
**Key Insight:** BFS → Queue | DFS → Stack/Recursion.

---

## Recursion / Backtracking
**Concept:** Explore all possible states via recursive search and backtrack.  
**Use-Cases:**
- Permutations & Combinations  
- N-Queens  
- Subset Sum  
- Sudoku Solver  
**Key Insight:** Base + Recursive case; undo choices after exploring.

---

## Dynamic Programming (DP)
**Concept:** Optimize overlapping subproblems with memoization/tabulation.  
**Core Patterns:**
- Longest Common Subsequence (LCS)  
- 0/1 Knapsack  
- Subset / Partition problems  
- DP on Strings / Grids / Subsequences  
**Key Insight:** Identify optimal substructure; convert recursion → iterative DP.

---

## Greedy Algorithms
**Concept:** Local optimum → Global optimum.  
**Use-Cases:**
- Interval Scheduling / Merging  
- Activity Selection  
- Huffman Encoding  
- Minimum Platforms  
**Key Insight:** Sort + choose optimal candidate at each step.

---

## Heap / Priority Queue
**Concept:** Efficiently access min/max in dynamic datasets.  
**Use-Cases:**
- Top K elements  
- Kth largest/smallest element  
- Merge K sorted lists  
- Dijkstra’s Algorithm  
**Key Insight:** Min-heap / Max-heap control element ordering.

---

## Binary Search
**Concept:** Halve search space iteratively or recursively.  
**Use-Cases:**
- Search in sorted array  
- Binary search on answer (parametric search)  
- Rotated sorted array  
- Peak element  
**Key Insight:** Define `mid` carefully; avoid infinite loops.

---

## Graph Algorithms
**Core Techniques:**
- BFS / DFS Traversal  
- Union-Find (Disjoint Set) – Cycle detection, Kruskal’s MST  
- Topological Sort – DAG ordering  
- Dijkstra / Bellman-Ford / Floyd-Warshall – Shortest paths  
**Key Insight:** Use adjacency list; analyze `V + E` complexity.

---

## Trie (Prefix Tree)
**Concept:** Efficient word storage & prefix search.  
**Use-Cases:**
- Word Dictionary  
- Auto-complete System  
- Prefix Matching  
- Longest Common Prefix  
**Key Insight:** Each node = character; traversal encodes prefixes.

---

## Linked List
**Operations:**
- Reverse linked list  
- Detect cycle (Floyd’s Tortoise & Hare)  
- Merge sorted lists  
- Intersection of linked lists  
**Key Insight:** Maintain head/tail pointers and handle `null` safely.

---

## Stack / Queue
**Stack (LIFO):**
- Valid Parentheses  
- Next Greater Element  
- Monotonic Stack  
**Queue (FIFO):**
- Sliding Window Maximum  
- BFS Level Traversal  
**Key Insight:** Stack → reversal logic | Queue → order maintenance.

---

## LRU Cache
**Concept:** Eviction policy maintaining least recently used items.  
**Implementation:** Doubly Linked List + HashMap  
**Operations:**  
- `get()` → O(1)  
- `put()` → O(1)  
**Key Insight:** Maintain usage order dynamically.

---

## Segment Tree
**Concept:** Range queries and updates in logarithmic time.  
**Use-Cases:**
- Range sum/min/max  
- Range updates  
- Interval aggregation  
**Key Insight:** Divide array segments; each node = merged info.

---

## Complexity Summary

| Category | Avg Time | Space |
|-----------|-----------|--------|
| Sliding Window | O(n) | O(1) |
| Two Pointers | O(n) | O(1) |
| BFS/DFS | O(V + E) | O(V) |
| DP | O(n²) | O(n²) |
| Greedy | O(n log n) | O(1) |
| Heap/PQ | O(log n) | O(n) |
| Binary Search | O(log n) | O(1) |
| Trie | O(L) | O(ALPHABET_SIZE × L) |
| Linked List | O(n) | O(1) |
| Stack/Queue | O(n) | O(n) |
| LRU Cache | O(1) per op | O(capacity) |
| Segment Tree | O(log n) | O(4n) |

---

## MIT Insight
> “Every FAANG problem maps to a known pattern.  
> Master **pattern recognition → optimization → communication.**”

---

### Recommended Practice Platforms
- **LeetCode** – Pattern mastery  
- **AlgoExpert** – Structured problem sets  
- **InterviewBit** – Level-based progression  
- **Codeforces / AtCoder** – Competitive reinforcement

---

### Reference
- *MIT 6.006 – Introduction to Algorithms*  
- *CLRS – Algorithms (Cormen, Leiserson, Rivest, Stein)*  
- *LeetCode Discuss Patterns Collection*

---










